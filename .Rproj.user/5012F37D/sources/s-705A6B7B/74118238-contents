#' Generate Summary Table Comparing Group Medians
#'
#' Creates table (or figure) comparing the median of \code{y} across levels of
#' \code{x}.
#'
#' If \code{x} has 2 levels, a Mann-Whitney U (also known as Wilcoxon
#' rank-sum) test is used to test whether the distribution of \code{y} differs
#' in the two groups; if \code{x} has more than 2 levels, a Kruskal-Wallis test
#' is used to test whether the distribution of \code{y} differs across at
#' least two of the groups. Observations with missing values for \code{x} and/or
#' \code{y} are dropped.
#'
#'
#' @inherit tabmeans references
#' @inheritSection tabmeans Note
#' @inheritParams tabmeans
#'
#'
#' @param columns Character vector specifying what columns to include. Choices
#' for each element are \code{"n"} for total sample size, \code{"overall"} for
#' overall median, \code{"xgroups"} for \code{x} group medians, \code{"diff"}
#' for difference in \code{x} group medians (only available for binary
#' \code{x}), \code{"test"} for test statistic, and \code{"p"} for p-value.
#'
#' @param parenth Character string specifying what values are shown in
#' parentheses after the medians in each cell. Choices are \code{"none"},
#' \code{"iqr"}, \code{"q1q3"} for first and third quartiles, \code{"range"},
#' \code{"minmax"}, and \code{"ci"} for 95\% confidence interval for the medians
#' based on normal approximation to binomial.
#'
#'
#' @return Character matrix comparing median \code{y} across levels of \code{x}.
#'
#'
#' @examples
#' # Load in sample dataset and drop rows with missing values
#' data(tabdata)
#' tabdata <- tabdata[complete.cases(tabdata), ]
#'
#' # Compare median BMI in control group vs. treatment group
#' (medtable1 <- tabmedians(x = tabdata$Group, y = tabdata$BMI))
#'
#' # Compare median BMI by quartile of age
#' (medtable2 <- tabmedians(x = tabdata$Age, y = tabdata$BMI, quantiles = 4))
#'
#' # Create single table comparing median BMI and median age in control vs.
#' # treatment group
#' (medtable3 <- rbind(tabmedians(x = tabdata$Group, y = tabdata$BMI),
#'                     tabmedians(x = tabdata$Group, y = tabdata$Age)))
#'
#' # An easier way to make this table is to use tabmulti
#' medtable4 <- tabmulti(data = tabdata, xvarname = "Group",
#'                       yvarnames = c("BMI", "Age"), ymeasures = "median")
#'
#'
#' @export
tabmedians <- function(x, y, columns = c("xgroups", "p"), parenth = "iqr",
                       sep.char = ", ", xname = NULL, xlevels = NULL,
                       yname = NULL, text.label = NULL, quantiles = NULL,
                       quantile.vals = FALSE, format.latex = FALSE,
                       decimals = NULL, p.decimals = c(2, 3), p.cuts = 0.01,
                       p.lowerbound = 0.001, p.leading0 = TRUE,
                       p.avoid1 = FALSE, n.headings = TRUE,
                       bold.colnames = FALSE, variable.colname = "Variable",
                       fig = FALSE, print.html = FALSE,
                       html.filename = "table1.html", ...) {

  # If xname or yname unspecified, use variable names
  if (is.null(xname) & fig) {
    xname <- deparse(substitute(x))
    if (grepl("\\$", xname)) {
      xname <- strsplit(xname, "\\$")[[1]][2]
    }
  }
  if (is.null(yname)) {
    yname <- deparse(substitute(y))
    if (grepl("\\$", yname)) {
      yname <- strsplit(yname, "\\$")[[1]][2]
    }
  }

  # Drop missing values
  locs.complete <- which(! is.na(x) & ! is.na(y))
  x <- x[locs.complete]
  y <- y[locs.complete]

  # Create quantiles if necessary
  if (!is.null(quantiles)) {
    x <- cut(x = x, breaks = quantile(x, probs = seq(0, 1, 1 / quantiles)),
             include.lowest = TRUE, right = TRUE, dig.lab = 3)
  }

  # Calculate various statistics
  medians <- tapply(X = y, INDEX = x, FUN = median)
  ns <- tapply(X = y, INDEX = x, FUN = length)

  median.y <- median(y)
  n <- sum(ns)

  xvals <- names(medians)
  num.groups <- length(medians)

  # If decimals is unspecified, set to appropriate value
  if (is.null(decimals)) {
    max.median <- max(abs(medians))
    if (max.median >= 1000 | max.median == 0) {
      decimals <- 0
    } else if (max.median < 1000 & max.median >= 10) {
      decimals <- 1
    } else if (max.median < 10 & max.median >= 0.1) {
      decimals <- 2
    } else if (max.median < 0.1 & max.median >= 0.01) {
      decimals <- 3
    } else if (max.median < 0.01 & max.median >= 0.001) {
      decimals <- 4
    } else if (max.median < 0.001 & max.median >= 0.0001) {
      decimals <- 5
    } else if (max.median < 0.0001) {
      decimals <- 6
    }
  }

  # If xlevels unspecified, set to actual values
  if (is.null(xlevels)) {
    if (! is.null(quantiles)) {
      if (quantile.vals) {
        xlevels <- paste("Q", 1: num.groups, " ", xvals, sep = "")
      } else {
        xlevels <- paste("Q", 1: num.groups, sep = "")
      }
    } else {
      xlevels <- xvals
    }
  }

  if (! fig) {

    # Hypothesis test
    if (length(xlevels) == 2) {

      # Mann-Whitney U test a.k.a. Wilcoxon rank-sum test
      fit <- wilcox.test(y ~ x)
      message(paste("Mann-Whitney U was used to test whether the distribution of ",
                    yname, " differs in the two groups.", sep = ""))
      test.stat <- fit$statistic
      test.label <- "W"
      p <- fit$p.value

    } else {

      # Kruskal-Wallis rank-sum test
      fit <- kruskal.test(y ~ as.factor(x))
      message(paste("Kruskal-Wallis was used to test whether the distribution of ",
                    yname, " differs across at least two of the groups.",
                    sep = ""))
      test.stat <- fit$statistic
      test.label <- "Chi-sq"
      p <- fit$p.value

    }

    # Figure out text.label for first column of table
    if (is.null(text.label)) {
      if (parenth == "none") {
        text.label <- ", Median"
      } else if (parenth == "iqr") {
        text.label <- ", Median (IQR)"
      } else if (parenth == "range") {
        text.label <- ", Median (range)"
      } else if (parenth == "minmax") {
        text.label <- paste(", Median (min", sep.char, "max)", sep = "")
      } else if (parenth == "q1q3") {
        text.label <- paste(", Median (Q1", sep.char, "Q3)", sep = "")
      } else if (parenth == "ci") {
        text.label <- ", Median (95% CI)"
      }
    } else {
      text.label <- paste(",", text.label)
    }

    # Initialize table
    tbl <- matrix(paste(yname, text.label, sep = ""), ncol = 1,
                  dimnames = list(NULL, variable.colname))

    # Convert decimals to variable for sprintf
    spf <- paste("%0.", decimals, "f", sep = "")

    # Loop through column input and add each
    for (ii in 1: length(columns)) {

      column.ii <- columns[ii]

      if (column.ii == "n") {

        # N
        newcol <- matrix(n, dimnames = list(NULL, "N"))

      } else if (column.ii == "overall") {

        # Overall
        median.y <- median(y)
        if (parenth == "none") {
          overall.cell <- paste(sprintf(spf, median.y))
        } else if (parenth == "iqr") {
          overall.cell <- paste(sprintf(spf, median.y), " (",
                                sprintf(spf, IQR(y)), ")", sep = "")
        } else if (parenth == "q1q3") {
          overall.cell <-
            paste(sprintf(spf, median.y), " (",
                  sprintf(spf, quantile(y, probs = 0.25)), sep.char,
                  sprintf(spf, quantile(y, probs = 0.75)), ")", sep = "")
        } else if (parenth == "range") {
          overall.cell <- paste(sprintf(spf, median.y), " (",
                                sprintf(spf, diff(range(y))), ")", sep = "")
        } else if (parenth == "minmax") {
          overall.cell <- paste(sprintf(spf, median.y), " (",
                                sprintf(spf, min(y)), sep.char,
                                sprintf(spf, max(y)), ")", sep = "")
        } else if (parenth == "ci") {

          zcrit <- qnorm(p = 0.975)
          sort.y <- sort(y)
          lower <- sort.y[n / 2 - zcrit * sqrt(n) / 2]
          upper <- sort.y[1 + n / 2 + zcrit * sqrt(n) / 2]
          overall.cell <- paste(sprintf(spf, median.y), " (",
                                sprintf(spf, lower), sep.char,
                                sprintf(spf, upper), ")", sep = "")

        }
        newcol <- matrix(overall.cell, dimnames = list(NULL, "Overall"))

      } else if (column.ii == "xgroups") {

        # Median (parenth)
        if (parenth == "none") {
          groups.cells <- paste(sprintf(spf, medians))
        } else if (parenth == "iqr") {
          iqrs <- tapply(X = y, INDEX = x, FUN = IQR)
          group.cells <- paste(sprintf(spf, medians), " (",
                               sprintf(spf, iqrs), ")", sep = "")
        } else if (parenth == "q1q3") {
          q1s <- tapply(X = y, INDEX = x, FUN = function(x) {
            quantile(x, probs = 0.25)
          })
          q3s <- tapply(X = y, INDEX = x, FUN = function(x) {
            quantile(x, probs = 0.75)
          })
          group.cells <- paste(sprintf(spf, medians), " (",
                               sprintf(spf, q1s), sep.char,
                               sprintf(spf, q3s), ")", sep = "")
        } else if (parenth == "range") {
          ranges <- tapply(X = y, INDEX = x, FUN = function(x) diff(range(x)))
          group.cells <- paste(sprintf(spf, medians), " (",
                               sprintf(spf, ranges), ")", sep = "")
        } else if (parenth == "minmax") {
          mins <- tapply(X = y, INDEX = x, FUN = min)
          maxes <- tapply(X = y, INDEX = x, FUN = max)
          group.cells <- paste(sprintf(spf, medians), " (",
                               sprintf(spf, mins), sep.char,
                               sprintf(spf, maxes), ")", sep = "")
        } else if (parenth == "ci") {
          zcrit <- qnorm(p = 0.975)
          lower <- tapply(X = y, INDEX = x, FUN = function(x) {
            sort(x)[length(x) / 2 - zcrit * sqrt(length(x)) / 2]
          })
          upper <- tapply(X = y, INDEX = x, FUN = function(x) {
            sort(x)[1 + length(x) / 2 + zcrit * sqrt(length(x)) / 2]
          })
          group.cells <- paste(sprintf(spf, medians), " (",
                               sprintf(spf, lower), sep.char,
                               sprintf(spf, upper), ")", sep = "")
        }

        newcol <- matrix(group.cells, nrow = 1, dimnames = list(NULL, xlevels))

      } else if (column.ii == "diff") {

        # Diff.
        newcol <- matrix(sprintf(spf, -diff(medians)),
                         dimnames = list(NULL, "Diff."))

      } else if (column.ii == "test") {

        # W/Chi-sq.
        newcol <- matrix(sprintf(spf, test.stat),
                         dimnames = list(NULL, test.label))

      } else if (column.ii == "p") {

        # P
        p.formatted <- formatp(p = p, cuts = p.cuts, decimals = p.decimals,
                               lowerbound = p.lowerbound, leading0 = p.leading0,
                               avoid1 = p.avoid1)
        newcol <- matrix(p.formatted, dimnames = list(NULL, "P"))

      }

      # Add column to table
      tbl <- cbind(tbl, newcol)

    }

    # Add sample sizes to column headings if requested
    if (n.headings) {

      colnames(tbl)[colnames(tbl) == "Overall"] <-
        paste("Overall (n = ", n, ")", sep = "")
      colnames(tbl)[colnames(tbl) %in% xlevels] <-
        paste(xlevels, " (n = ", ns, ")", sep = "")

    }

    # Make column names bold if requested
    if (format.latex & bold.colnames) {
      colnames(tbl) <- paste("$\\textbf{", colnames(tbl), "}$", sep = "")
    }

    # Print html version of table if requested
    if (print.html) {

      tbl.xtable <-
        xtable(tbl, align = paste("ll",
                                  paste(rep("r", ncol(tbl) - 1), collapse = ""),
                                  sep = "", collapse = ""))
      print(tbl.xtable, include.rownames = FALSE, type = "html",
            file = html.filename, sanitize.text.function = function(x) {
              ifelse(substr(x, 1, 1) == " ", paste("&nbsp &nbsp", x), x)
            })

    }

  } else {

    if (parenth %in% c("iqr", "q1q3")) {

      lowerbars <- tapply(X = y, INDEX = x, FUN = function(x) {
        quantile(x, probs = 0.25)
      })
      upperbars <- tapply(X = y, INDEX = x, FUN = function(x) {
        quantile(x, probs = 0.75)
      })
      ylabel <- paste(yname, " (Median, IQR)", sep = "")

    } else if (parenth %in% c("range", "minmax")) {

      lowerbars <- tapply(X = y, INDEX = x, FUN = min)
      upperbars <- tapply(X = y, INDEX = x, FUN = max)
      ylabel <- paste(yname, " (Median, range)", sep = "")

    } else if (parenth == "q1q3") {

      lowerbars <- tapply(X = y, INDEX = x, FUN = min)
      upperbars <- tapply(X = y, INDEX = x, FUN = max)
      ylabel <- paste(yname, " (Median, range)", sep = "")

    } else if (parenth == "ci") {

      lowerbars <- tapply(X = y, INDEX = x, FUN = function(x)
        sort(x)[length(x) / 2 - qnorm(p = 0.975) * sqrt(length(x)) / 2])
      upperbars <- tapply(X = y, INDEX = x, FUN = function(x)
        sort(x)[length(x) / 2 + qnorm(p = 0.975) * sqrt(length(x)) / 2])

      ylabel <- paste(yname, " (Median +/- 95% CI")

    }

    # Save ... into extra.args list
    extra.args <- list(...)

    if (parenth == "none") {

      # Figure out plot inputs if not specified
      if (is.null(extra.args$main)) {
        extra.args$main <- paste("Median ", yname, " by ", xname, sep = "")
      }
      if (is.null(extra.args$xlim)) {
        extra.args$xlim <- c(0.5, (length(xlevels) + 0.5))
      }
      if (is.null(extra.args$ylim)) {
        bar.range <- max(medians) - min(medians)
        extra.args$ylim <- c(min(medians) - 0.2 * bar.range,
                             max(medians) + 0.2 * bar.range)
      }
      if (is.null(extra.args$xlab)) {
        extra.args$xlab <- xname
      }
      if (is.null(extra.args$ylab)) {
        extra.args$ylab <- paste(yname, " (Median)", sep = "")
      }
      if (is.null(extra.args$cex.lab)) {
        extra.args$cex.lab <- 1.1
      }
      if (is.null(extra.args$pch)) {
        extra.args$pch <- 19
      }

      # Create figure
      tbl <- do.call(plot, c(list(x = 1: length(medians), y = medians,
                                  xaxt = "n"), extra.args))
      axis(side = 1, at = 1: length(xlevels), labels = xlevels)

    } else {

      # Figure out plot inputs if not specified
      if (is.null(extra.args$main)) {
        extra.args$main <- paste("Median ", yname, " by ", xname, sep = "")
      }
      if (is.null(extra.args$xlim)) {
        extra.args$xlim <- c(0.5, length(xlevels) + 0.5)
      }
      if (is.null(extra.args$ylim)) {
        bar.range <- max(c(lowerbars, upperbars)) - min(c(lowerbars, upperbars))
        ylim1 <- min(c(lowerbars, upperbars) - 0.1 * bar.range)
        ylim2 <- max(c(lowerbars, upperbars) + 0.1 * bar.range)
        extra.args$ylim <- c(ylim1, ylim2)
      }
      if (is.null(extra.args$xlab)) {
        extra.args$xlab <- xname
      }
      if (is.null(extra.args$cex.lab)) {
        extra.args$cex.lab <- 1.1
      }
      if (is.null(extra.args$ylab)) {
        extra.args$ylab <- ylabel
      }

      # Create figure
      tbl <- do.call(plot, c(list(x = NULL, y = NULL), extra.args))
      for (ii in 1:length(lowerbars)) {

        endpoints <- c(lowerbars[ii], upperbars[ii])
        points(x = ii, y = medians[ii], pch = 19)
        lines(x = rep(ii, 2), y = endpoints)
        lines(x = c((ii - 0.03), (ii + 0.03)), y = rep(endpoints[1], 2))
        lines(x = c((ii - 0.03), (ii + 0.03)), y = rep(endpoints[2], 2))

      }
      axis(side = 1, at = 1:length(xlevels), labels = xlevels)

    }

    tbl <- recordPlot()

  }

  # Return table
  return(tbl)

}
