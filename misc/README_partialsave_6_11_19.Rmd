---
output: github_document
title: "Summary Tables with 'tab'"
author: "Dane Van Domelen <br> vandomed@gmail.com"
date: "`r Sys.Date()`"
bibliography: vignettes/bibliography.bib
nocite: | 
  @Kmisc, 
  @knitr1,
  @knitr2,
  @knitr3,
  @pander,
  @printr,
  @survival-package, 
  @survival-book,
  @xtable
  
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  message = FALSE
)

# Load packages
library("tab")
library("xtable")
library("knitr")
library("gee")

# Set xtable options
options("xtable.caption.placement" = "top", 
        "xtable.include.rownames" = TRUE, 
        "xtable.comment" = FALSE)
```

## Installation

You can install and load **tab** from GitHub via the following code:

```{r, eval = FALSE}
devtools::install_github("vandomed/tab")
library("tab")
```

## Functions

The purpose of **tab** is to make it easier to create tables for papers, including Table 1's showing characteristics of the sample and summary tables for fitted regression models. Currently, the following functions are included:

* `tabmeans` compares means in two or more groups.
* `tabmedians` compares medians in two or more groups.
* `tabfreq` compares frequencies in two or more groups. 
* `tabmulti` compares multiple variables in two or more groups.
* `tabmeans.svy`, `tabmedians.svy`, `tabfreq.svy`, and `tabmulti.svy` serve the same purposes as the above functions, but for complex survey data.
* `tabglm` summarizes generalized linear models (GLM's) fit via `glm` or `survey::svyglm`. 
* `tabgee` summarizes generalized estimating equation models (GEE's) fit via `gee::gee`. 
* `tabcoxph` summarizes Cox Proportional Hazards models fit via `survival::coxph` or `survey::svycoxph`.

## Table 1's

<!-- A toy dataset called `tabdata` is included in **tab** package. It is a data frame with 15 variables and 300 observations. Let's take a look: -->

<!-- ```{r toydata} -->
<!-- library("tab") -->
<!-- head(tabdata) -->
<!-- ``` -->

You can use `tabmulti` to compare characteristics across levels of a factor variable, e.g. here comparing age, sex, and race by treatment group in the toy dataset `tabdata`.

```{r}
tabmulti(Age + Sex + Race ~ Group, data = tabdata) %>% kable()
```

To illustrate some options, we can request `Age` and `Race` to print as `Age (years)` and `Race/ethnicity`, compare medians rather than means for age, and include the sample sizes in the column headings:

```{r}
tabmulti(Age + Sex + Race ~ Group, data = tabdata, 
         yvarlabels = list(Age = "Age (years)", Race = "Race/ethnicity"), 
         ymeasures = c("median", "freq", "freq"), 
         listwise.deletion = TRUE, 
         n.headings = TRUE) %>% kable()
```


## Regression tables

### GLM's

Logistic regression for 1-year mortality vs. age, sex, and treatment, with the 
binary factor variables displayed in a "compressed" format:

```{r}
fit <- glm(death_1yr ~ Age + Sex + Group, data = tabdata, family = binomial)
fit %>% tabglm(factor.compression = 5) %>% kable()
```

### GEE's

GEE for high blood pressure (measured at 3 time points longitudinally) vs. 
various predictors, with some higher-order terms:

```{r echo = TRUE, eval = FALSE}
tabdata2 <- reshape(data = tabdata,
                    varying = c("bp.1", "bp.2", "bp.3", "highbp.1", "highbp.2", "highbp.3"),
                    timevar = "bp.visit", direction = "long")
tabdata2 <- tabdata2[order(tabdata2$id), ]
fit <- gee(highbp ~ poly(Age, 2, raw = TRUE) + Sex + Race + Race*Sex,
           id = id, data = tabdata2, family = "binomial", corstr = "unstructured")
fit %>% tabgee(data = tabdata2) %>% kable()
```

```{r include = FALSE}
tabdata2 <- reshape(data = tabdata,
                    varying = c("bp.1", "bp.2", "bp.3", "highbp.1", "highbp.2", "highbp.3"),
                    timevar = "bp.visit", direction = "long")
tabdata2 <- tabdata2[order(tabdata2$id), ]
fit <- gee(highbp ~ poly(Age, 2, raw = TRUE) + Sex + Race + Race*Sex,
           id = id, data = tabdata2, family = "binomial", corstr = "unstructured")
```

```{r echo = FALSE}
fit %>% tabgee(data = tabdata2) %>% kable()
```

Note that we had to set `data = tabdata2` here, because `gee` objects don't store all of the information on factor variables (unlike `glm` objects).


### Cox proportional hazards

Survival model for mortality vs. predictors, again compressing the factor variables:

```{r}
library("survival")
fit <- coxph(Surv(time = time, event = delta) ~ Age + Sex + Group, data = tabdata)
fit %>% tabcoxph(factor.compression = 5) %>% kable()
```


## Complex survey data

The functions in **tab** can also accommodate complex survey data. To illustrate with the included dataset `tabsvydata` (which is data from NHANES 2003-2004, except for the made-up variables `time` and `event`), here's a Table 1:

```{r message=FALSE, warning=FALSE}
library("survey")
design <- svydesign(
  data = tabsvydata,
  ids = ~sdmvpsu,
  strata = ~sdmvstra,
  weights = ~wtmec2yr,
  nest = TRUE
)
tabmulti.svy(Age + Race + BMI ~ Sex, design = design) %>% kable()
```

And here's a linear regression:

```{r message=FALSE, warning=FALSE}
fit <- svyglm(BMI ~ Age + Sex + Race, design = design)
fit %>% tabglm(factor.compression = 3) %>% kable()
```


## Exporting tables, e.g. to Word

All of the functions in **tab** have an argument called `print.html` which can 
be used to export tables to word processors. Setting `print.html = TRUE` will 
result in a HTML table being output to your current working directory. You can 
open the table (e.g. in Chrome) and copy/paste into your report.


## Options for printing in R

I used **knitr**'s `kable` function for the examples here, but you should also 
be able to use **xtable



<!-- ```{r table1b} -->
<!-- library("printr") -->
<!-- tabmulti(Age + Sex + Race ~ Group, data = tabdata) -->
<!-- detach("package:printr", unload = TRUE) -->
<!-- ``` -->

<!-- If you want to add table options, e.g. a caption or non-default column alignment, you can use `kable` from the **knitr** package (e.g. try `kable(table1, align = "lrrr", caption = "Table 1.", format = "html")`. -->

<!-- ```{r table1c, eval = TRUE, echo = FALSE} -->
<!-- library("knitr") -->
<!-- table1 <- tabmulti(Age + Sex + Race ~ Group, data = tabdata) -->
<!-- kable(table1, align = "lrrr", caption = "Table 1.", format = "html") -->
<!-- ``` -->





<!-- *tabmulti* created a character matrix, but it doesn't look like a table yet.  -->


<!-- ## Exporting to Word  -->

<!-- If you want to get the table into Microsoft Word, here are two approaches: -->

<!-- 1. Install/load **Kmisc** and run `write.cb(table1)` to copy the table to your clipboard. Paste the result into Word, then highlight the text and go to `Insert -> Table -> Convert Text to Table... OK`.  -->

<!-- 2. Add `print.html = TRUE` to the above *tabmulti* function call. That will result in a .html file being written to your working directory. It should appear as a neat table when you open it (e.g. in Google Chrome), and you can copy/paste it into Word.  -->

<!-- If you want it to display it in a **knitr** document, you can add `latex = TRUE` and then use various approaches... -->


<!-- ## Printing in R -->

<!-- ### printr -->

<!-- I think the easiest approach is to simply load the **printr** package. Loading it results in R output printing more neatly, which includes character matrices showing up as neat tables. -->

<!-- ```{r table1b} -->
<!-- library("printr") -->
<!-- (table1 <- tabmulti(data = tabdata,  -->
<!--                     xvarname = "Group",  -->
<!--                     yvarnames = c("Age", "Sex", "Race"),  -->
<!--                     latex = TRUE)) -->
<!-- detach("package:printr", unload = TRUE) -->
<!-- ``` -->

<!-- (I detached **printr** so R reverts to its usual output display format for the rest of the vignette.) -->

<!-- If you want to add table options, e.g. a caption or non-default column alignment, you can use `kable` from the **knitr** package (e.g. try `kable(table1, align = "lrrr", caption = "Table 1.", format = "html")`.  -->

<!-- ```{r table1c, eval = FALSE, echo = FALSE} -->
<!-- library("printr") -->
<!-- library("knitr") -->
<!-- kable(table1, align = "lrrr", caption = "Table 1.", format = "html") -->
<!-- detach("package:printr", unload = TRUE) -->
<!-- ``` -->
<!-- <br> -->

<!-- ### knitr's *kable* function -->

<!-- ```{r table1d} -->
<!-- library("knitr") -->
<!-- kable(table1, -->
<!--       caption = "Table 1a. Characteristics (created by tabmulti/kable).",  -->
<!--       align = 'lrrr',  -->
<!--       format = "html") -->
<!-- ``` -->
<!-- <br> -->

<!-- ### xtable's *xtable* function -->

<!-- Another option is the **xtable** package/function (requires adding `results = "asis"` as a chunk option!): -->

<!-- ```{r table1e, results = "asis"} -->
<!-- library("xtable") -->
<!-- print(xtable(table1,  -->
<!--              caption = "Table 1b. Characteristics (created by tabmulti/xtable).",  -->
<!--              align = 'llrrr'),  -->
<!--       type = "html",  -->
<!--       include.rownames = FALSE) -->
<!-- ``` -->
<!-- <br> -->

<!-- ### pander's *pandoc.table* function -->

<!-- And finally the *pandoc.table* function in **pander** (also requires `results = "asis"`): -->

<!-- ```{r table1f, results = "asis"} -->
<!-- library("pander") -->
<!-- pandoc.table(table1,  -->
<!--              caption = "Table 1c. Characteristics (created by tabmulti/pandoc.table).",  -->
<!--              style = "rmarkdown",  -->
<!--              justify = 'lrrr',  -->
<!--              split.tables = Inf) -->
<!-- ``` -->


<!-- ## More on *tabmulti* -->

<!-- Recall the *tabmulti* function call from above: -->

<!-- ```{r tabmulti1, eval = FALSE} -->
<!-- table1 <- tabmulti(data = tabdata,  -->
<!--                    xvarname = "Group",  -->
<!--                    yvarnames = c("Age", "Sex", "Race"),  -->
<!--                    latex = TRUE) -->
<!-- ``` -->

<!-- I specified the data frame, the name of the group variable, and the names of the variables I wanted to compare. By default, *tabmulti* treats each Y variable as continuous if it is numeric and takes on 5 or more unique values, and categorical otherwise. It compares means for continuous variables and frequencies for categorical variables. -->

<!-- Internally, *tabmulti* called *tabmeans* for the first comparison and *tabfreq* for the second and third. We could have created the same table using these functions and *rbind*: -->

<!-- ```{r tabmulti2} -->
<!-- table1b <- rbind(tabmeans(x = tabdata$Group, y = tabdata$Age, latex = TRUE),  -->
<!--                  tabfreq(x = tabdata$Group, y = tabdata$Sex, latex = TRUE),  -->
<!--                  tabfreq(x = tabdata$Group, y = tabdata$Race, latex = TRUE)) -->
<!-- all(table1 == table1b) -->
<!-- ``` -->

<!-- Let's go through some more options. The `columns` input controls what columns are shown, with the default `columns = c("xgroups", "p")` requesting a column for each `x` level and the p-value (from t-test or ANOVA). Since we have missing values and *tabmulti* uses pairwise deletion by default, let's add a sample size column, and why not also throw in a column for the overall sample statistics.  -->

<!-- ```{r tabmulti3} -->
<!-- table1 <- tabmulti(data = tabdata,  -->
<!--                    xvarname = "Group",  -->
<!--                    yvarnames = c("Age", "Sex", "Race"), -->
<!--                    columns = c("n", "overall", "xgroups", "p"), -->
<!--                    latex = TRUE) -->
<!-- kable(table1,  -->
<!--       caption = "Table 1d. Characteristics of sample.",  -->
<!--       align = 'lrrrrr',  -->
<!--       format = "html") -->
<!-- ``` -->

<!-- For age, often the range is more informative than the SD. We can display M (min-max) rather than M (SD) but setting the *tabmeans* input `parenth = "sd"`. To pass this argument through *tabmulti*, we use the `means.list` argument: -->

<!-- ```{r tabmulti4} -->
<!-- table1 <- tabmulti(data = tabdata,  -->
<!--                    xvarname = "Group",  -->
<!--                    yvarnames = c("Age", "Sex", "Race"), -->
<!--                    columns = c("n", "overall", "xgroups", "p"), -->
<!--                    means.list = list(parenth = "minmax"), -->
<!--                    latex = TRUE) -->
<!-- kable(table1,  -->
<!--       caption = "Table 1e. Characteristics of sample.",  -->
<!--       align = 'lrrrrr',  -->
<!--       format = "html") -->
<!-- ``` -->

<!-- Technically the range is the difference between the min and the max, not the min and the max, but if you prefer the label `"M (range)"`, you could specify the `text.label` input: `means.list = list(parenth = "minmax", text.label = "M (range)")`. -->

<!-- These are some of the options you have access to with *tabmulti* and the underlying functions it calls. A complete list of options are described in the help files for *tabmulti*, *tabmeans*, *tabmedians*, and *tabfreq*. The help files also have some different examples. -->


<!-- ## Regression summaries -->

<!-- ### Linear regression -->

<!-- Suppose we want to summarize a linear regression of BMI on age, sex, race, and treatment group. You could use *kable*, *xtable*, or *pandoc.table* to print a summary table like this: -->

<!-- ```{r linreg1, results = "asis"} -->
<!-- fit <- glm(BMI ~ Age + Sex + Race + Group, data = tabdata) -->
<!-- print(xtable(fit,  -->
<!--              caption = "Table 2a. Linear regression fit (created by xtable)."),  -->
<!--       type = "html") -->
<!-- ``` -->

<!-- But this isn't how a regression table in a paper typically looks. A few issues: -->

<!-- * P-value column should have a simpler heading. -->
<!-- * P-values should not print as 0.  -->
<!-- * For factor variables, levels should be printed more cleanly. -->

<!-- Let's try *tabglm*: -->

<!-- ```{r linreg2} -->
<!-- table2 <- tabglm(fit = fit,  -->
<!--                  latex = TRUE) -->
<!-- kable(table2,  -->
<!--       caption = "Table 2b. Linear regression fit (created by tabglm/kable).",  -->
<!--       align = 'lrr',  -->
<!--       format = "html") -->
<!-- ``` -->

<!-- If you don't like all the white space, you can set `compress.factors = TRUE` to omit rows with factor variable names (and left-align factor levels). By default, the input `omit.refgroups` has the same value as `compress.factors`, and `omit.refgroups = TRUE` omits reference group rows. -->

<!-- ```{r linreg3, eval = TRUE} -->
<!-- table2 <- tabglm(fit = fit,  -->
<!--                  compress.factors = TRUE, -->
<!--                  latex = TRUE) -->
<!-- kable(table2,  -->
<!--       caption = "Table 2c. Linear regression fit (created by tabglm/kable).",  -->
<!--       align = 'lrr',  -->
<!--       format = "html") -->
<!-- ``` -->

<!-- Maybe you're submitting to one of those enlightened journals that thinks comparing confidence intervals to 0 is totally different than comparing p-values to 0.05. *tabglm* can do confidence intervals: -->

<!-- ```{r linreg4, eval = TRUE} -->
<!-- table2 <- tabglm(fit = fit,  -->
<!--                  columns = c("beta.se", "betaci"), -->
<!--                  compress.factors = TRUE, -->
<!--                  latex = TRUE) -->
<!-- kable(table2,  -->
<!--       caption = "Table 2d. Linear regression fit (created by tabglm/kable).",  -->
<!--       align = 'lrr',  -->
<!--       format = "html") -->
<!-- ``` -->
<!-- <br> -->

<!-- ### Logistic regression -->

<!-- Summarizing a fitted logistic regression model with *tabglm* is very similar. For 1-year mortality vs. age, age squared, sex, race, and treatment group: -->

<!-- ```{r logreg1, eval = TRUE} -->
<!-- fit <- glm(death_1yr ~ poly(Age, 2, raw = TRUE) + Sex + Race + Group,  -->
<!--            data = tabdata, family = "binomial") -->
<!-- table3 <- tabglm(fit = fit,  -->
<!--                  compress.factors = "binary",  -->
<!--                  latex = TRUE) -->
<!-- kable(table3,  -->
<!--       caption = "Table 3. Logistic regression fit (created by tabglm/kable).",  -->
<!--       align = 'lrrr',  -->
<!--       format = "html") -->
<!-- ``` -->

<!-- Notice that the second-order term was labeled appropriately, and *tabglm* recognized `fit` as a logistic regression and thus by default added a OR (95% CI) column. Additionally, the binary Sex and Group variables was displayed as single rows, while the other factor variable, Race, was shown in a more expanded format. This was the result of setting `compress.factors = "binary"` (`compress.factors` can be `TRUE`, `FALSE`, or `"binary"`). -->

<!-- ### GEEs -->

<!-- To summarize a fitted GEE, we can convert `tabdata` from wide to long format, fit a GEE, and then call *tabgee*. Here's a table for blood pressure vs. age, sex, race, BMI, and treatment group, with columns for Beta, SE, Z, and P: -->

<!-- ```{r gee1, eval = TRUE} -->
<!-- tabdata2 <- reshape(data = tabdata, -->
<!--                     varying = c("bp.1", "bp.2", "bp.3", "highbp.1", -->
<!--                                 "highbp.2", "highbp.3"), -->
<!--                     timevar = "bp.visit",  -->
<!--                     direction = "long") -->
<!-- tabdata2 <- tabdata2[order(tabdata2$id), ] -->
<!-- fit <- gee(bp ~ Age + Sex + Race + BMI + Group,  -->
<!--            id = id,  -->
<!--            data = tabdata2, -->
<!--            corstr = "unstructured") -->
<!-- table4 <- tabgee(fit = fit,  -->
<!--                  columns = c("beta", "se", "z", "p"), -->
<!--                  compress.factors = "binary",  -->
<!--                  data = tabdata2,  -->
<!--                  latex = TRUE) -->
<!-- kable(table4,  -->
<!--       caption = "Table 4. GEE fit (created by tabgee/kable).",  -->
<!--       align = 'lrrr',  -->
<!--       format = "html") -->
<!-- ``` -->
<!-- <br> -->

<!-- ### Cox PH -->

<!-- And finally, to summarize a fitted Cox PH model for survival vs. covariates, with default settings: -->

<!-- ```{r coxph1, eval = TRUE} -->
<!-- tabdata <- tabdata[complete.cases(tabdata), ] -->
<!-- fit <- coxph(Surv(time = tabdata$time, event = tabdata$delta) ~  -->
<!--                Age + Sex + Race + Group,  -->
<!--              data = tabdata) -->
<!-- table5 <- tabcox(fit = fit,  -->
<!--                  latex = TRUE) -->
<!-- kable(table5,  -->
<!--       caption = "Table 5. Cox PH fit (created by tabcox/kable).",  -->
<!--       align = 'lrrr',  -->
<!--       format = "html") -->
<!-- ``` -->


<!-- ## Closing comments -->

<!-- * I suggest **printr** with *kable* for alignment, captions, etc. -->
<!-- * Working on functions for complex survey data. -->
<!-- * Feel free to collaborate on [GitHub](https://github.com/vandomed/tab)! -->


<!-- ## References -->
